### План разработки: Chat-CLI

**Этап 1: Базовая функциональность чата (MVP)**

Цель этого этапа — запустить базовый интерактивный чат с одним, жёстко закодированным провайдером. Это создаст основу приложения.

1.  **Реализовать команду `new`**:
    *   Реализовать логику в `cli/commands/new.py` для создания нового каталога проекта.
    *   Добавить функциональность для создания файла `config.json` по умолчанию и пустого файла базы данных `chat.db`.
2.  **Реализовать команду `run`**:
    *   Доработать `cli/commands/run.py` для запуска интерактивной сессии.
    *   Интегрировать библиотеку `prompt-toolkit` для удобного интерфейса командной строки (она уже есть в `requirements.txt`).
3.  **Базовая интеграция с API**:
    *   Реализовать `BaseProvider` в `cli/api/base_provider.py`.
    *   Интегрировать `DummyProvider` из `cli/api/dummy_provider.py` для имитации ответов API.
4.  **Интерактивный цикл**:
    *   Создать основной цикл чата, который принимает ввод пользователя, отправляет его провайдеру и выводит ответ.

**Этап 2: Управление беседами и историей**

На этом этапе вводится персистентность, позволяющая пользователям сохранять, загружать и управлять своими беседами.

1.  **Модели базы данных**:
    *   Определить модели SQLAlchemy в `cli/database/models.py` для `Conversation`, `Message` и `ConfigurationSettings`.
2.  **Интеграция с базой данных**:
    *   Использовать `Alembic` для управления миграциями базы данных.
    *   Интегрировать сессии базы данных (`cli/database/session.py`) в цикл чата для сохранения всех сообщений.
3.  **Управление контекстом**:
    *   Реализовать логику для автоматического построения контекста (истории беседы), который будет отправляться с каждым новым запросом.
    *   Добавить команды, позволяющие пользователю просматривать, включать/отключать или удалять предыдущие сообщения из контекста.
4.  **Сохранение/загрузка бесед**:
    *   Создать команды, такие как `chat save <name>` и `chat load <name>`, для управления различными ветками бесед.

**Этап 3: Продвинутая инженерия запросов**

На этом этапе добавляются специализированные функции для инженерии запросов, упомянутые в `README.md`.

1.  **Редактирование запросов**:
    *   Реализовать команду, которая позволяет пользователю открывать предыдущий запрос в своем текстовом редакторе по умолчанию (`$EDITOR`), сохранять изменения и заново генерировать беседу с этой точки.
2.  **Визуализация диалога**:
    *   Создать команду `chat tree`, которая отображает текущую беседу в виде ветвящегося дерева, что особенно полезно для изучения различных ответов на один и тот же запрос.
3.  **Обогащение контекста**:
    *   Добавить команду (`chat add-context <file>`) для простого добавления содержимого файла в историю беседы в качестве контекста для модели.

**Этап 4: Поддержка нескольких провайдеров и конфигурация**

Этот этап сосредоточен на создании подключаемого модуля API и предоставлении пользователю возможности настраивать приложение.

1.  **Интеграция с реальным API**:
    *   Создать конкретную реализацию для первого реального провайдера (например, `GroqProvider`), которая будет обрабатывать запросы к API и получать ответы.
2.  **Управление ключами API**:
    *   Реализовать простой и безопасный способ загрузки ключа API из переменной окружения.
3.  **Динамическая загрузка провайдеров**:
    *   Провести рефакторинг интеграции с API для динамической загрузки доступных модулей провайдеров из каталога `cli/api`.
4.  **Система конфигурации**:
    *   Создать сервис конфигурации (`cli/services/config.py`), который считывает настройки из файла (например, `~/.chat_cli/config.json`).
    *   Использовать `templates/default_config.json` для создания конфигурации по умолчанию для новых пользователей.
    *   Предоставить пользователям возможность выбирать провайдера и модель по умолчанию в файле конфигурации.
5.  **Команда выбора модели**:
    *   Добавить команду (например, `chat model <provider>.<model>`), позволяющую пользователям переключать активную языковую модель для текущей сессии.
6.  **Гибкие настройки нейросети**:
    *   Предоставить пользователям возможность указывать параметры модели (такие как `temperature`, `max_tokens`) как в файле конфигурации, так и в качестве опций в команде `run`.